ThreadPoolExecutor:
    1: corePoolSize 线程池中的常驻核心线程数
    2：maximumPoolSize 线程池能够容纳同时执行的最大线程数，此值必须大于等于1
    3：keepAliveTime 多余的空闲线程的存活时间
        当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，
        多余空闲线程会被销毁直到只剩下corePoolSize个线程为止
    4: unit keepAliveTime的单位
    5：workQueue 任务队列，被提交但尚未被执行的任务
    6：threadFactory 表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可
    7：handler 拒绝策略，表示当队列满了并且工作线程大于等于最大线程数（maximumPoolSize）时如何来拒绝请求
    执行的Runnable的策略（RejectedExecutionHandler)
            AbortPolicy(默认)：直接抛出RejectedExecutionException 异常阻止系统正常运行
            DiscardPolicy：“调用者运行”一种调节机制，该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
            CallerRunsPolicy：抛弃队列中等待最久的任务，然而把当前任务加入队列中常侍再次提交任务
            DiscardOlderPolicy：直接丢弃任务，不予任何处理也不抛弃异常。如果允许任务丢失，这是最好的一种方案。
            
如何设置线程数：
    1：cpu密集型：cpu密集的意思时该任务需要大量的运算，而没有阻塞，cpu一直全速运行。
    cpu密集任务只有在真正的多核cpu上才能得到加速（通多多线程）
    而在单核cpu上，无论你开几个模拟的多线程该任务都不可能得到加速，因为cpu总的运算能力就那些。
    cpu密集型任务配置尽可能少的线程数量
    一般公式：cpu核数+1个线程的线程池
    2：IO密集型，即该任务需要大量的IO，即大量的阻塞。
    在单线程上运行IO密集型的任务会导致大量的cpu运算能力浪费在等待上。
    所以在IO密集型任务中使用多线程可以大大的加速程序运行，即使在单核cpu上，这种加速主要就是利用被浪费掉的阻塞时间。
    第一种：由于IO密集型任务线程并不是一直执行任务，则应配置尽可能多的线程，如cpu核数*2
    IO密集型时，大部分线程都阻塞，故需要多配置线程数：
    第二种：参考公式： cpu核数/1-阻塞系数            阻塞系数在0.8~0.9之间
    比如8核cpu：8/（1-0.9） = 80个线程数
        
        
死锁: 死锁是指两个或者两个以上的进程在执行过程中，因为争夺资源而造成的一种互相等待的现象，若无外力干涉那它们将无法推进下去，
如果系统资源充足，进程的资源请求都能得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。
       原因总结：
            1：系统资源不足
            2：进程运行推进的顺序不合适
            3：资源分配不当        
        